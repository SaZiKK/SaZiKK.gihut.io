---
comments: true
title: 【开发日志】chaos开发日志
Author: SaZiKK
categories:
  - OS
  - develop
date modify:  2024-05-18 22:17:07 +0800
date: 2024-05-14 16:29:17 +0800
tags:
  - os
  - competition
date create:  2024-05-14 16:29:17 +0800
---
这是2024系统能力大赛操作系统内核赛道作品chaos开发日志，本项目基于ArceOS开发。
### 2024.5.14
结束前置学习，克隆项目，配置工作区。

### 2024.5.20
基本了解ArceOS思想及架构，进行初步更改。

### ArceOS基本架构思想
ArceOS最大的特点就是组件化开发，它把系统内核的功能拆分为了系统有关和系统无关，也就是不可移植和可移植的区别。不可移植的模块叫module，命名以ax开头；可移植的模块叫crate，与内核只通过接口交流。

#### ArceOS实现全流程syscall过程
要想明白应该如何在ArceOS的架构中实现一个syscall，最好的方式就是从用户出发，从用户的syscall请求开始回溯。

在ArceOS中，用户直接面对的是来自用户库`ulib`的接口，用户只需要直接调用其中接口即可，在调用的同时，用户也要对应的启用一定的`feature`，这也是ArceOS的特色之一，我们先按下不表。深入`ulib`，仔细参考接口的实现后，可以发现接口都是对于`arceos_api`中方法的封装，正如其名字所说的那样，`arceos_api`提供了一系列面向用户库的接口，如最基础的`ax_console_read_byte`等。这里可以看到ArceOS的代码规范非常好，所有mod和lib文件都是非常干净的接口引用，没有添加任何功能代码的实现。

再进入`arceos_api`，我们就可以看到这里的方法来自各个module，同时我们熟悉的`sys_*`函数也分布在这里。实现过syscall的朋友们都知道（迫真），到这里就是一个`原子syscall`（我自己瞎取的名），即所有内核功能在这里首次被打包成一个完整syscall，再进行层层封装。

了解了syscall的调用流程，想要实现一个syscall也就简单了，具体syscall过程中，特权级的切换，上下文的保存等我还没有深究，还要继续研究，但是中断实现上应该都大差不差。

需要注意的是syscall的具体实现方法。ArceOS为我们实现了一个奇妙的宏`syscall_body`，我们需要传入syscall_id等参数，对于参数的主要操作也就是syscall的主要部分都在里面完成，宏如其名了属于是。


### Todos：
- [ ] 加载APP并运行全流程
- [ ] 中断处理
- [ ] 内存管理
- [ ] 文件系统 
- [ ] 
