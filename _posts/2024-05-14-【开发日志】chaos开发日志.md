---
comments: true
title: 【开发日志】chaos开发日志
Author: SaZiKK
categories:
  - OS
  - develop
date modify:  2024-06-20 15:12:48 +0800
date: 2024-05-14 16:29:17 +0800
tags:
  - os
  - competition
date create:  2024-05-14 16:29:17 +0800
---
这是2024系统能力大赛操作系统内核赛道作品chaos开发日志，本项目基于~~ArceOS~~ rCore开发。
### 2024.5.14
结束前置学习，克隆项目，配置工作区。

### 2024.5.20
基本了解ArceOS思想及架构，进行初步更改。

#### ArceOS基本架构思想
ArceOS最大的特点就是组件化开发，它把系统内核的功能拆分为了系统有关和系统无关，也就是不可移植和可移植的区别。不可移植的模块叫module，命名以ax开头；可移植的模块叫crate，与内核只通过接口交流。

#### ArceOS实现全流程syscall过程
要想明白应该如何在ArceOS的架构中实现一个syscall，最好的方式就是从用户出发，从用户的syscall请求开始回溯。

在ArceOS中，用户直接面对的是来自用户库`ulib`的接口，用户只需要直接调用其中接口即可，在调用的同时，用户也要对应的启用一定的`feature`，这也是ArceOS的特色之一，我们先按下不表。深入`ulib`，仔细参考接口的实现后，可以发现接口都是对于`arceos_api`中方法的封装，正如其名字所说的那样，`arceos_api`提供了一系列面向用户库的接口，如最基础的`ax_console_read_byte`等。这里可以看到ArceOS的代码规范非常好，所有mod和lib文件都是非常干净的接口引用，没有添加任何功能代码的实现。

再进入`arceos_api`，我们就可以看到这里的方法来自各个module，同时我们熟悉的`sys_*`函数也分布在这里。实现过syscall的朋友们都知道（迫真），到这里就是一个`原子syscall`（我自己瞎取的名），即所有内核功能在这里首次被打包成一个完整syscall，再进行层层封装。

了解了syscall的调用流程，想要实现一个syscall也就简单了，具体syscall过程中，特权级的切换，上下文的保存等我还没有深究，还要继续研究，但是中断实现上应该都大差不差。

需要注意的是syscall的具体实现方法。ArceOS为我们实现了一个奇妙的宏`syscall_body`，我们需要传入syscall_id等参数，对于参数的主要操作也就是syscall的主要部分都在里面完成，宏如其名了属于是。

### 2024.5.23

淦，ArceOS看不下去了，转投rCore

#### 修改测试逻辑和用例
修改`Makefile`，让chaos可以运行初赛测例，同时基本删除原有的应用，只保留`shell`和`initproc`，再自定义了一个应用用于一键执行所有应用。

基本思路就是把编译好的elf初赛测例也和rust应用的elf文件塞到一起然后一起加载，rCore原有的流程扩展性不强，因此花了不少时间改。

#### 新建dev分支开发syscall

新维护了一个dev分支，同时队友大改文件系统，分了一个feat分支出去。

感觉换成rCore之后前途一片光明（完犊紫）啊。

### 2024.5.24

#### 实现`SYS_times`
统计一下进程的内核和用户态clock时间，之前写过，没什么难度。大致可以参考rCore的习题`扩展内核，统计每个应用完成时间`。

#### 修改测例顺序
王老板在参考linux源码重构文件系统，暂时不处理文件系统相关syscall，把文件系统相关syscall放到了后面。

#### 实现`SYS_uname`
只是输出固定字符串而已，非常简单，但是一定一定要注意在我们内核内部，u8数组的长度要和riscv标准下的`utsname`结构体的成员字符数组长度保持一致，都是65字节，长度不一致就会导致切片复制时出错。

### 2024.5.25

#### （4:38 am）实现`SYS_wait4`
只需要修复rCore的`sys_waitpid`方法即可。

这里踩了不少雷。首先是需要搞清楚对于`SYS_wait4`的调用函数看似很多而且各不相同，实际上都是`SYS_wait4`通过封装派生出来的，因此安安稳稳实现就行。

其次是`WEXITSTATUS`宏的问题。`WEXITSTATUS`宏名义上会取`wstatus`的低8位，作为子进程的退出状态，但是阅读其源码会发现，所谓低8位指的是小端法下的低8位！鬼知道为什么这里会出现小端！！因此在赋值的时候我们需要把传进去的`exit_code`左移8位来保证其存储在小端上（这里就偷懒不交换两端而是直接左移了），这样才能正确解析出退出状态值，通过测例。参考往届的代码也没有在这里做特殊处理，暂时不知道他怎么过的测例，猜测是FAT32文件系统发力了，而我们尚未实现FAT32，王老板还在猛肝。

#### （7:24 am）实现`SYS_brk`
要实现`SYS_brk`，首先要支持堆的操作。我为地址空间memory_set新增维护了其对应的堆空间，地址即为elf文件中读到的地址，这个地址原本被用作user_stack_top，即用户栈顶，然后将用户栈顶放置到一个固定地址0x100000000，最后再把`UserTaskRes`维护的的用户栈底`ustack_base`改为用户栈顶`ustack_top`，维护相关方法。妥善维护上面所有修改之后就可以动手实现syscall了，具体的实现参考了往届的学长，按照传入地址修改堆区末尾指针位置在再修改映射即可。

#### 实现`SYS_nanosleep`
设置一个预计时间，反复循环忙等待到时间到达即可，期间进程直接yield。（或许应该block？）

#### 维护了阻塞队列`block_queue`
还未实现具体应用。

#### 实现`SYS_getppid`
过于简单，不做赘述。

### 2024.5.26

#### 完成FAT32文件系统
王老板写完了FAT32，分支merge进了dev。王老板牛逼。

#### 修复`LoadPageFault`的问题
加入文件系统之后遇到了严重的错误，所有的应用都能正常读取，但是全部报`LoadPageFault`，非法的地址是用户栈顶。debug了一整天后认为和文件系统和内存管理都无关，最后发现是分配的用户栈没有没有左闭右开，然后读取右边的栈顶就炸了，但是原来的rCore没有维护这个问题。进一步思考后发现应该是因为引入文件系统镜像之后取消了初始进程`initproc`，由他`fork`出的进程用户栈地址空间都合法的维护了，而取消了初始进程之后，所有应用申请的用户栈地址空间读取右边就会非法，因为他们都变成了0号进程。

至于为什么初始进程作为0号进程可以正常运行，我们认为是初始进程使用了`no_main`feature，这样他在启动的时候就不会首先读取用户栈顶获取`main`函数的参数。目前的解决办法是暂时给用户栈顶 -4 ，等完成了所有syscall之后再修复。具体的修复方案暂定是额外打包一个包含了初始进程的镜像一起上传。

### 2024.5.28

#### 实现`SYS_clone`
`SYS_clone`我调了足足两天，问题来自于参数的不匹配以及参考资料的稀少。en读了Linux源码和测例提供的部分glibc之后选择单独为测例实现一个`fork2`，即创建新进程，且执行自定义函数。测例提供的lib很关键，因为测例的lib是经过魔改的，`clone`函数的实现被替换成了自定义的汇编函数，阅读汇编代码可知，需要运行的函数指针并不会直接传给内核，而是会把它和函数参数一起压栈，再把栈指针传入内核，因此只需要把子进程中断上下文中保存的栈指针替换成传入的栈指针即可实现执行指定的函数。

#### 修复`SYS_execve`
加文件系统后会`StorePageFault`，猜测是内核栈爆了，开了两倍的内核栈成功修好。

#### 实现`SYS_fstat`
`SYS_fstat`在rCore-lab期间已经完成，只是`Stat`结构体的内容不同，因此修改结构体，维护一下内容即可。因为测例没有要求，目前仅维护了文件大小。

#### 重构`SYS_mmap`
之前的`SYS_mmap`过于原始，耦合度高且映射方式存在问题，因此给予重构。

首先是映射位置需要再修改，对于`flag`没有指明是`FIXED`的映射，我们不需要按照传入的虚拟地址直接映射，而是应该指定一个地址用于匿名映射，并以这个地址为基准进行映射。为此我们规定`MMAP_BASE`为0x20000000，然后为每个地址空间维护`mmap_base`和`mmap_end`，用于管理映射。对于指定了`FIXED`的映射，我们按照之前那样直接映射。

其次是文件映射，`SYS_mmap`要求能够实现文件映射，也就是在映射一块空间的同时把指定文件的数据初始化在这段内存中，`copy_from_slice`一下即可。

#### 实现`SYS_munmap`
`SYS_mmap`改了，`SYS_munmap`当然也要改。取消映射就简单多了，修改`mmap_end`再unmap一下就行。

### 2024.5.29（凌晨）

#### 比赛环境配置

到这里，所有的`syscall`都实现了，接下来就是配置环境尝试提交。

首先要做的是把所有外部包改为本地编译，因为测评机不联网。统一放进一个`vendor`文件夹管理即可。
然后是修改一下`Makefile`，满足测评要求的同时维护一下`.cargo`，因为测评机`clone`项目时会忽略隐藏文件夹，需要交上去再在`make`的时候改名。
最后我们要在`rust-toolchain`里指定`building targets`，并且在`cargo.toml`里添加`rustflags = ["-Zbuild-std=core,alloc"]`，确保编译时包含`core`库。
这样我们提交后就可以成功得到成绩（~~已经寄了7发了~~）

## **通过初赛！**
小修两个bug，9发提交满分通过，排名14

---

### 2024.6.19 开始重构
摆了一段时间开始计划重构代码，首先的目标是取消rCore的双页表机制，双页表虽然可以防侧信道攻击，但是带来的性能开销也很大，与我们的目标不符。

取消双页表也是为下一步进一步实现无栈协程做铺垫，修改为内核态用户态共用页表之后就可以按照无栈协程的一般处理方式，让进程共用内核栈。

### 2024.6.20


### Todos：
- [x] 继续实现syscall
- [ ] 彻底实现block queue
- [x] fork时复制mmap区域
- [ ] 为waitpid启用block机制
- [ ] 添加初始进程，修复用户栈顶问题
- [ ] 完整实现clone、execve
- [ ] 重构代码
- [ ] 无栈异步协程调度
- [ ] 内核态中断
- [ ] 内核态用户态共用页表
  - [ ] 检查用户态传入地址
- [ ] 实现多核
- [ ] 页缓存
- [ ] inode缓存
- [ ] 写时复制
- [ ] 共享页映射
- [ ] Lazy分配
- [ ] mmap内存拷贝优化
- [ ] 
