---
title: rCoreLab笔记
Author: SaZiKK
categories:
  - OS
  - study
date create: 2024-04-29 14:04:46 +0800
date: 2024-04-30 17:04:02 +0800
tags:
  - os
  - rCore
---
完成rCoreLab的学习笔记。实验指导手册：[rCore-Tutorial-Guide-2024S 文档 (learningos.cn)](https://learningos.cn/rCore-Tutorial-Guide-2024S/)

ch1和2没有lab，所以实验从ch3开始。在实验开始前，我已经完整阅读了[rCore-Tutorial-Book 第三版](https://rcore-os.cn/rCore-Tutorial-Book-v3/chapter0/index.html)直到ch6的内容以及代码，因此在代码理解上没有很大的障碍。
### ch3 实现`sys_task_info`系统调用
该系统调用要求获取任务控制块相关信息（任务状态）、任务使用的系统调用及调用次数、系统调用时刻距离任务第一次被调度时刻的时长（单位ms）。
```rust
struct TaskInfo {
    status: TaskStatus,
    syscall_times: [u32; MAX_SYSCALL_NUM],
    time: usize
}
```
由于获取的是当前任务，因此状态一定为`Running`，下面着重分析统计系统调用次数和计时的实现。

首先是统计并获取系统调用次数，我采取的方法是在TCB中维护系统调用次数，然后为TaskManager实现对应方法维护并获取。
```rust
//os/src/task/task.rs

pub struct TaskControlBlock {
    /// The task status in it's lifecycle
    pub task_status: TaskStatus,
    /// The task context
    pub task_cx: TaskContext,
    /// the syscall times
    pub syscall_times: [u32; MAX_SYSCALL_NUM],
}
```

```rust
//os/src/task/mod.rs impl TaskManager

///update syscall times and get syscall times
fn count_syscall_times(&self, id: usize) -> [u32; MAX_SYSCALL_NUM] {
	let mut inner = self.inner.exclusive_access();
	let current = inner.current_task;
	if id <= MAX_SYSCALL_NUM {
		inner.tasks[current].syscall_times[id] += 1;
	}
	inner.tasks[current].syscall_times
}
```
最后在Traphandler中系统调用的入口处调用该方法实现系统调用计数，并在syscall中调用方法查询计数。在syscall函数里的方法调用传入了一个越界的数，这样就不会修改系统调用的计数，仅返回查询到的结果。
```rust
//os/src/trap/mod.rs

pub fn trap_handler(cx: &mut TrapContext) -> &mut TrapContext {
    let scause = scause::read(); // get trap cause
    let stval = stval::read(); // get extra value
                               // trace!("into {:?}", scause.cause());
    match scause.cause() {
        Trap::Exception(Exception::UserEnvCall) => {
            let syscall_id = cx.x[17];
             //count syscall times
             count_syscall_times_from_current(syscall_id);
            // jump to next instruction anyway
            cx.sepc += 4;
            // get system call return value
            cx.x[10] = syscall(cx.x[17], [cx.x[10], cx.x[11], cx.x[12]]) as usize;
        }
        ...
}
```
值得注意的是，上述实现方法并不好，TCB作为一个经常需要被复制和移动的资源应该尽可能简洁，只存放进程本身需要的数据，这样的写法会影响性能且耦合度高，更优的写法是在TaskManager中统一管理各个进程的syscall次数。当然更优只针对ch3的代码，在后续我们对进程的操作和管理趋于复杂时，TaskManager里存放的数据也应该和对应进程的生命周期同步销毁，需要额外花精力去维护。

在实现获取进程运行时间时，我一开始误解了题意，排除了并发的影响，维护了进程实际运行时间。我借鉴了练习题中统计应用完成时间的设计，在TCB中维护了进程在内核态和用户态的执行时间，这样虽然避免了并发带来的影响，但是题意要求的是计算包含并发调度开销在内的总时长。

![[../assets/figures/Pasted image 20240430162904.png|../assets/figures/Pasted image 20240430162904.png]]