---
title: rCoreLab笔记
Author: SaZiKK
categories:
  - OS
  - study
date create: 2024-04-29 14:24:46 +0800
date: 2024-04-30 21:24:39 +0800
tags:
  - os
  - rCore
---
完成rCoreLab的学习笔记。实验指导手册：[rCore-Tutorial-Guide-2024S 文档 (learningos.cn)](https://learningos.cn/rCore-Tutorial-Guide-2024S/)

ch1和2没有lab，所以实验从ch3开始。在实验开始前，我已经完整阅读了[rCore-Tutorial-Book 第三版](https://rcore-os.cn/rCore-Tutorial-Book-v3/chapter0/index.html)直到ch6的内容以及代码，因此在代码理解上没有很大的障碍。
## Chapter3    实现`sys_task_info`系统调用
### 代码部分：
该系统调用要求获取任务控制块相关信息（任务状态）、任务使用的系统调用及调用次数、系统调用时刻距离任务第一次被调度时刻的时长（单位ms）。
```rust
struct TaskInfo {
    status: TaskStatus,
    syscall_times: [u32; MAX_SYSCALL_NUM],
    time: usize
}
```
由于获取的是当前任务，因此状态一定为`Running`，下面着重分析统计系统调用次数和计时的实现。

首先是统计并获取系统调用次数，我采取的方法是在TCB中维护系统调用次数，然后为`TaskManager`实现对应方法维护并获取。
```rust
//os/src/task/task.rs

pub struct TaskControlBlock {
    /// The task status in it's lifecycle
    pub task_status: TaskStatus,
    /// The task context
    pub task_cx: TaskContext,
    /// the syscall times
    pub syscall_times: [u32; MAX_SYSCALL_NUM],
}
```

```rust
//os/src/task/mod.rs impl TaskManager

///update syscall times and get syscall times
fn count_syscall_times(&self, id: usize) -> [u32; MAX_SYSCALL_NUM] {
	let mut inner = self.inner.exclusive_access();
	let current = inner.current_task;
	if id <= MAX_SYSCALL_NUM {
		inner.tasks[current].syscall_times[id] += 1;
	}
	inner.tasks[current].syscall_times
}
```
最后在`Traphandler`中系统调用的入口处调用该方法实现系统调用计数，并在syscall中调用方法查询计数。在syscall函数里的方法调用传入了一个越界的数，这样就不会修改系统调用的计数，仅返回查询到的结果。
```rust
//os/src/trap/mod.rs

pub fn trap_handler(cx: &mut TrapContext) -> &mut TrapContext {
    let scause = scause::read(); // get trap cause
    let stval = stval::read(); // get extra value
                               // trace!("into {:?}", scause.cause());
    match scause.cause() {
        Trap::Exception(Exception::UserEnvCall) => {
            let syscall_id = cx.x[17];
             //count syscall times
             count_syscall_times_from_current(syscall_id);
            // jump to next instruction anyway
            cx.sepc += 4;
            // get system call return value
            cx.x[10] = syscall(cx.x[17], [cx.x[10], cx.x[11], cx.x[12]]) as usize;
        }
        ...
}
```
值得注意的是，上述实现方法并不好，TCB作为一个经常需要被复制和移动的资源应该尽可能简洁，只存放进程本身需要的数据，这样的写法会影响性能且耦合度高，更优的写法是在`TaskManager`中统一管理各个进程的syscall次数。当然更优只针对ch3的代码，在后续我们对进程的操作和管理趋于复杂时，`TaskManager`里存放的数据也应该和对应进程的生命周期同步销毁，需要额外花精力去维护。

在实现获取进程运行时间时，我一开始误解了题意，排除了并发的影响，维护了进程实际运行时间。我借鉴了练习题中统计应用完成时间的设计，在TCB中维护了进程在内核态和用户态的执行时间，这样虽然避免了并发带来的影响，但是题意要求的是计算**包含并发调度开销在内**的总时长。下图是打印出的调试信息，可以看到实际时间和计算并发后的时间相差了接近一倍。
![](../assets/figures/Pasted%20image%2020240430162904.png)
修改实现思路后，我在TaskManager里为所有进程维护了第一次调度时间`task_start_time`，并在`run_first_task`  `run_next_task`方法中更新，这样只要在查询时间时，用`get_time_ms`获取当前时间作差即可
```rust
//os/src/task/mod.rs

pub struct TaskManagerInner {
    /// task list
    tasks: [TaskControlBlock; MAX_APP_NUM],
    /// id of current `Running` task
    current_task: usize,
    last_stop_time: usize,
    task_start_time: [usize; MAX_APP_NUM],
}

impl TaskManagerInner{
    fn run_first_task(&self) -> ! {
        ...
        //开始计时
        inner.task_start_time[0] = get_time_ms();
        inner.refresh_last_stop_time();
        ...
    }

    fn run_next_task(&self) {
        if let Some(next) = self.find_next_task() {
            ...
            //如果是第一次调用，维护第一次调度时间
            if inner.task_start_time[next] == 0 {
                inner.task_start_time[next] = get_time_ms();
            }
            ...
        } else {
            panic!("All applications completed!");
        }
    }
    ///在内核态获取运行时间
    fn count_task_time(&self) -> usize {
        let inner = self.inner.exclusive_access();
        let current = inner.current_task;
        let total_time = get_time_ms() - inner.task_start_time[current];
        total_time
    }
}

///get task process time
pub fn count_current_task_time() -> usize {
    TASK_MANAGER.count_task_time()
} 
```
最后将各个接口打包成syscall函数，chapter3的lab代码部分就完成了
```rust
pub fn sys_task_info(_ti: *mut TaskInfo) -> isize {
    trace!("kernel: sys_task_info");
    //id设置为超过上限的数表示查询
    let syscall_times = count_syscall_times_from_current(MAX_SYSCALL_NUM + 1);
    let time = count_current_task_time();
    unsafe{
       (*_ti) = TaskInfo{
        status: TaskStatus::Running,
        syscall_times,
        time,
        }; 
    } 
    0
}
```
### 简答部分：
#### 深入理解 [trap.S](https://github.com/LearningOS/rCore-Tutorial-Code-2024S/blob/ch3/os/src/trap/trap.S) 中两个函数 `__alltraps` 和 `__restore` 的作用，并回答如下问题:
#### 1. L40：刚进入 `__restore` 时，`a0` 代表了什么值。请指出 `__restore` 的两种使用情景。
`__restore`是trap后返回用户态的处理函数，因此此时a0的值应该是系统调用函数返回值或异常处理函数返回值。`__restore`在系统调用返回或异常处理返回时被调用。
#### 2. L43-L48：这几行汇编代码特殊处理了哪些寄存器？这些寄存器的的值对于进入用户态有何意义？请分别解释。
```Assembly
ld t0, 32*8(sp)
ld t1, 33*8(sp)
ld t2, 2*8(sp)
csrw sstatus, t0
csrw sepc, t1
csrw sscratch, t2
```
上述代码使用了三个CSR特权寄存器`sstatus` `sepc`和`sscratch`，在进入trap时，`sstatus`和`sepc`的值会被瞬间覆盖掉。其中`sstatus`用来存储和控制CPU的各种特权和状态信息，这里是恢复trap处理前存储的信息；`sepc`寄存器用来存储中断处下一条指令的位置，恢复`sepc`的值以从中断处继续执行；`sscratch`寄存器的值不会因为特权级切换等原因改变，用来保存一些临时数据，如中断上下文等，这里恢复的是用户栈位置；以上三个特权级寄存器只有在S mode才能使用。
#### 3. L50-L56：为何跳过了 `x2` 和 `x4`？

```Assembly
ld x1, 1*8(sp)
ld x3, 3*8(sp)
.set n, 5
.rept 27
   LOAD_GP %n
   .set n, n+1
.endr
```
tp(x4)一般不会被用到，除非哦我们手动使用它，因此没有必要保存；而sp(x2)后面还要使用，我们需要依靠栈指针加偏移量来找到其他寄存器应该保存的正确位置。没有保存自然也没必要恢复。
#### 4. L60：该指令之后，`sp` 和 `sscratch` 中的值分别有什么意义？
```Assembly
csrrw sp, sscratch, sp
```
这里是相当于交换了`sscratch`和`sp`的值，执行前`sp`指向内核栈指针，`sscratch`指向用户栈指针；这条指令执行后，`sp`就指向了用户栈，为回到用户态做准备。
#### 5. `__restore`：中发生状态切换在哪一条指令？为何该指令执行之后会进入用户态？
特权级切换发生在`sret`，这条指令用于从一个特权态的trap中返回。`sret`会把特权级恢复到`sstatus`寄存器的SPP字段存储的值，即上一个特权级，这样CPU就回到了用户态。`sret`还会把`sstatus`的SIE字段设置为SPIE( Supervisor Previous Interrupt Enable)字段，即恢复上一个中断使能位的状态，同时SPIE会被设置为1，SPP会被设置为支持的最低特权级（一般是User）。
#### 6. L13：该指令之后，`sp` 和 `sscratch` 中的值分别有什么意义？
```Assembly
csrrw sp, sscratch, sp
```
同4，只不过切换结果相反
#### 7. 从 U 态进入 S 态是哪一条指令发生的？
```Assembly
call trap_handler
```
 如果在异常处理中进行了系统调用，就会切换到S态，因为syscall函数实现中使用了`ecall`指令

到这里chapter3的内容就结束了
